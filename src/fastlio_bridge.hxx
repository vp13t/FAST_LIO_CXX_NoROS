// fastlio_bridge.hxx
#pragma once
#include <memory>
#include <optional>
#include <string>
#include <vector>
#include "msg.h"
#include "fastlio_cxx_noros/src/fastlio_bindings.rs.h" // generated by cxx

// struct TimeMsg { int64_t sec; int64_t nsec; };
// struct HeaderMsg { uint32_t seq; TimeMsg stamp; std::string frame_id; };

// namespace geometry_msgs {
// struct Vector3Msg { float x, y, z; };
// struct QuaternionMsg { float x, y, z, w; };
// struct PoseMsg { Vector3Msg position; QuaternionMsg orientation; };
// struct PoseStampedMsg { HeaderMsg header; PoseMsg pose; };
// struct PoseWithCovarianceMsg { PoseMsg pose; std::vector<double> covariance; }; // len 36
// struct TwistMsg { Vector3Msg linear; Vector3Msg angular; };
// struct TwistWithCovarianceMsg { TwistMsg twist; std::vector<double> covariance; }; // len 36
// }

// namespace sensor_msgs {
// struct PointFieldMsg { std::string name; uint32_t offset; uint8_t datatype; uint32_t count; };
// struct PointCloud2Msg {
//     HeaderMsg header;
//     uint32_t height, width;
//     bool is_bigendian;
//     uint32_t point_step, row_step;
//     bool is_dense;
//     std::vector<uint8_t> data;
//     std::vector<PointFieldMsg> fields;
// };
// struct ImuMsg {
//     HeaderMsg header;
//     geometry_msgs::QuaternionMsg orientation;
//     std::vector<float> orientation_covariance;     // len 9
//     geometry_msgs::Vector3Msg angular_velocity;
//     std::vector<float> angular_velocity_covariance; // len 9
//     geometry_msgs::Vector3Msg linear_acceleration;
//     std::vector<float> linear_acceleration_covariance;
// };
// }

// namespace nav_msgs {
// struct PathMsg { HeaderMsg header; std::vector<geometry_msgs::PoseStampedMsg> poses; };
// struct OdometryMsg {
//     HeaderMsg header;
//     std::string child_frame_id;
//     geometry_msgs::PoseWithCovarianceMsg pose;
//     geometry_msgs::TwistWithCovarianceMsg twist;
// };
// }

// struct LidarOutputMsg {
//     bool has_laser_cloud_full, has_laser_cloud_full_body, has_laser_cloud_effect,
//          has_laser_cloud_map, has_odom, has_path;
//     sensor_msgs::PointCloud2Msg laser_cloud_full, laser_cloud_full_body,
//                                 laser_cloud_effect, laser_cloud_map;
//     nav_msgs::OdometryMsg odom;
//     nav_msgs::PathMsg path;
// };

void fastlio_init();
void fastlio_save_map();
std::unique_ptr<LidarOutputMsg> fastlio_run();
void fastlio_imu_cbk(const sensor_msgs::ImuMsg &msg);
void fastlio_pcl_cbk(const sensor_msgs::PointCloud2Msg &msg);
